/*拷贝 赋值 销毁*/
// 拷贝构造函数
class Foo
{
    Foo();
    Foo(const Foo&);  //拷贝构造函数  第一个参数是个引用类型， 且会被隐式使用， 不该是explicit
};

// 拷贝初始化 靠拷贝构造函数 完成
// 如果有 移动构造函数  则可能用移动构造函数完成

/*  拷贝初始化可能发生的情况
1. =
2. 将对象作为实参 给一个非引用形参
3. 非引用的函数返回对象
4. 

*/

// 拷贝赋值运算符

/**
 * 重载运算符 本质上是函数  operator 加上 重载的符号  有返回类型 与 参数列表
 * 某些运算符必须定义为成员函数
 * 
 */

class Foo
{
public:
    Foo &operator=(const Foo&); //赋值运算
    // ・・・・・・
};

/**
 * 合成拷贝赋值运算符
 * 用户未定义 系统会自动合成
 * 有时用来禁止赋值
 * 不然赋值 右侧所有非static对象， 每个对象用各自类型的赋值运算符来完成
 * */

/**
 * 析构函数
 * ~Foo();
 * 没有 返回值  没有 参数列表
 * 不能被重载  一个类只有一个析构函数
 */

/** 需要析构函数的类也需要拷贝和赋值操作
 *  需要拷贝操作的类 也需要赋值操作， 反之亦然
 *  需要拷贝 赋值 不一定需要析构
 */

/** 使用 =default
 *  有合成版本的 就可以用 default
 * 
 */

/** 阻止拷贝
 * 
 * 
 */

//定义删除函数
struct NoCopy
{
    NoCopy() = default;
    NoCopy(const NoCopy&) = delete; // 阻止拷贝
    NoCopy &operator=(const NoCopy&) = delete; //阻止赋值
    ~NoCopy() = default;
};
// = delete告知编译器  不用这些函数
//析构函数 不能是删除的函数

// 合成的拷贝控制成员可以是删除的

// private 拷贝控制

